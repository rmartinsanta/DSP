package es.urjc.etsii.grafo.PDSP.pr;

import es.urjc.etsii.grafo.PDSP.algorithm.TabuSearchAlgorithm;
import es.urjc.etsii.grafo.PDSP.model.PDSPInstance;
import es.urjc.etsii.grafo.PDSP.model.PDSPSolution;
import es.urjc.etsii.grafo.algorithms.Algorithm;
import es.urjc.etsii.grafo.create.Constructive;
import es.urjc.etsii.grafo.util.DoubleComparator;
import es.urjc.etsii.grafo.util.TimeControl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static java.util.Comparator.comparing;

/**
 * Combination of Path Relinking (PR) and Tabu Search (TS) metaheuristics
 * The TS is responsible for generating a high quality solution set for the PR
 * The PR will take the solutions generated by the TS and a diverse set of solutions to combine them and generate new solutions.
 */
public class TabuRelinkedAlgorithm extends Algorithm<PDSPSolution, PDSPInstance> {

    private static final Logger log = LoggerFactory.getLogger(TabuRelinkedAlgorithm.class);

    protected final PathRelinking pathRelinking;

    /**
     * Number of solution for the path relinking by best value
     */
    private final int nSolutionsByScore;

    /**
     * Number of solutions for the path relinking by diversity
     */
    private final int nSolutionsByDiversity;

    private final TabuSearchAlgorithm qualityConstructive;
    private final Constructive<PDSPSolution, PDSPInstance> diversityConstructive;

    public TabuRelinkedAlgorithm(String name, int nSolutionsByDiversity, int nSolutionsByScore, PathRelinking pathRelinking, TabuSearchAlgorithm qualityConstructive, Constructive<PDSPSolution, PDSPInstance> diversityConstructive) {
        super(name);
        this.pathRelinking = pathRelinking;
        this.nSolutionsByScore = nSolutionsByScore;
        this.nSolutionsByDiversity = nSolutionsByDiversity;
        this.qualityConstructive = qualityConstructive;
        this.diversityConstructive = diversityConstructive;
    }

    @Override
    public PDSPSolution algorithm(PDSPInstance instance) {
        // Generate reference solutions for the path relinking
        var qualitySolutionsSet = new HashSet<PDSPSolution>();
        for (int i = 0; i < nSolutionsByScore; i++) {
            var solution = this.qualityConstructive.algorithm(instance);
            qualitySolutionsSet.add(solution);
            log.trace("Initial quality solution {} generated with score {}", i, solution.getScore());
            if(TimeControl.isTimeUp()) break;
        }
        log.debug("Finished generating initial solutions by quality: {} / {} unique", qualitySolutionsSet.size(), nSolutionsByScore);

        // Transform into array and sort by score
        var qualitySolutions = qualitySolutionsSet.toArray(new PDSPSolution[0]);
        Arrays.sort(qualitySolutions, comparing(PDSPSolution::getScore));

        // Generate diverse solution set using a different constructive
        var diverseSolutionsSet = new HashSet<PDSPSolution>();
        for (int i = 0; i < nSolutionsByDiversity; i++) {
            if(TimeControl.isTimeUp()) break;
            var solution = newSolution(instance);
            solution = diversityConstructive.construct(solution);
            diverseSolutionsSet.add(solution);
            log.trace("Initial diverse solution {} generated with score {}", i, solution.getScore());
        }
        log.debug("Finished generating initial solutions by diversity: {} / {} unique", diverseSolutionsSet.size(), nSolutionsByDiversity);

        // Transform into array and sort by score
        var diverseSolutions = diverseSolutionsSet.toArray(new PDSPSolution[0]);
        Arrays.sort(diverseSolutions, comparing(PDSPSolution::getScore));

        var best = runPR(diverseSolutions, qualitySolutions);
        return best;
    }

    private PDSPSolution getBest(Set<PDSPSolution> mprSolutions){
        double minV = Integer.MAX_VALUE;
        PDSPSolution bestInSet = null;
        for(var s: mprSolutions){
            if(s.getScore() < minV){
                minV = s.getScore();
                bestInSet = s;
            }
        }
        assert bestInSet != null;
        return bestInSet;
    }

    private PDSPSolution runPR(PDSPSolution[] diverseSolutions, PDSPSolution[] bestSolutions) {
        double bestExisting = bestSolutions[0].getScore();
        var newSolutions = pathRelinking.newSet(bestSolutions, new HashSet<>(Arrays.asList(diverseSolutions)));

        // if there are no solutions generated by the PR, return current best
        if(newSolutions.isEmpty()){
            log.debug("No new solutions generated by the PR");
            return bestSolutions[0];
        }

        // If PR generated solutions, return best found
        var best = getBest(newSolutions);
        double minV = best.getScore();

        // Log debug what has happened
        if(DoubleComparator.isLess(minV, bestExisting)){
            log.debug("Improved value after Path Relinking {} -> {}", bestExisting, minV);
            return best;
        } else if (DoubleComparator.equals(minV, bestExisting)){
            log.debug("Equal best value after Path Relinking {} -> {}", bestExisting, minV);
            return best;
        } else {
            log.debug("Worse best value after Path Relinking {} -> {}", bestExisting, minV);
            return bestSolutions[0];
        }
    }
}
